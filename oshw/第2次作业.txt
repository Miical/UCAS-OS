1.为什么开始启动计算机的时候，执行的是BIOS代码而不是操作系统自身的代码？

刚开始时内存中还并没有操作系统代码，只能获取到ROM中的BIOS代码，BIOS代码完成一系列工作然后加载操作系统代码。

2.为什么BIOS只加载了一个扇区，后续扇区却是由bootsect代码加载？为什么BIOS没有直接把所有需要加载的扇区都加载？

BIOS只加载一个扇区，一方面是出于历史原因，一方面是完成了计算机与操作系统设计者的约定。操作系统只需要尊重这一个约定，能够设计自己独特的加载机制。
在上述过程中，BIOS加载了一个扇区，通过约定完成了操作系统的加载。然后由加载进来的bootsect代码继续加载后续的扇区，这一过程是由操作系统自己设计的。

3.为什么BIOS把bootsect加载到0x07c00，而不是0x00000？加载后又马上挪到0x90000处，是何道理？为什么不一次加载到位？

以为 0x00000 处包含了BIOS最初设计的中断向量表，加载程序的过程正是通过中断来完成的。
0x07c00是BIOS约定的加载地址，BIOS加载bootsect到0x07c00，然后bootsect代码将自己挪到0x90000处，是为了满足操作系统设计者对内存的划分需求
0x07c00是约定好的地址，无法修改

4.bootsect、setup、head程序之间是怎么衔接的？给出代码证据。

bootsect加载完成程序以后，跳转到了setup
setup 关中断，把内核移动到0x0000，设置IDT和GDT，打开A20，编程中断，设置PE标志。通过jmpi 0, 8 跳转到head程序

5.setup程序的最后是jmpi 0,8 ，为什么这个8不能简单的当作阿拉伯数字8看待，究竟有什么内涵？

 8代表 1000。最后两位表示内核特权级，第三位表示 IDT/GDT，前面的1代表GDT中的下标，代表内核代码段

6.保护模式在“保护”什么？它的“保护”体现在哪里？特权级的目的和意义是什么？分页有“保护”作用吗？

保护模式使得用户进程无法访问内核空间以及相互访问。可以说是为了保护内核空间以及其他用户的数据。

# (需要进入保护模式)
# 1) 32位地址
# 2) 有特权级
# 3) 有虚拟地址
# 4) 中断

特权级、分页机制、段机制、中断机制等等，都是为了保护内核空间以及其他用户的数据。

特权级的目的是为了实现访问控制，用户程序拥有低特权级，内核拥有高特权级, ...

分页的前提是保护模式，也就是说，PE 和 PG必须同时打开，不存在没有PE的PG。可
以说分页和保护是一体的。分页机制同样依托 CPU的硬件，在提高了内存空间使用效率的
同时，也使操作系统的设计者能够实现用户进程之间不能互访，更不可能访问内核，而内核
实际上可以任意访问用户进程。


7.在setup程序里曾经设置过gdt，为什么在head程序中将其废弃，又重新设置了一个？为什么设置两次，而不是一次搞好？

原来GDT所在的位置是设计代码时在setup.s里面设置的数据，将来这个setup模块所在的内存位置会在设计缓冲区时被覆盖。
如果不改变位置，将来GDT的内容肯定会被缓冲区覆盖掉，从而影响系统的运行。
这样一来，将来整个内存中唯一安全的地方就是现在head.s所在的位置了。

那么有没有可能在执行 setup程序时直接把GDT的内容复制到head.s所在的位置呢?
肯定不能。如果先复制GDT的内容，后移动system模块，它就会被后者覆盖;如果先移动system模块，后复制GDT的内容，它又会把head.s对应的程序覆盖，
而这时head.s还没有执行。所以，无论如何，都要重新建立GDT。

8.内核的线性地址空间是如何分页的？画出从0x000000开始的7个页（包括页目录表、页表所在页）的挂接关系图，就是页目录表的前四个页目录项、第一个个页表的前7个页表项指向什么位置？给出代码证据。

...

9.根据内核分页为线性地址恒等映射的要求，推导出四个页表的映射公式，写出页表的设置代码。

	movl $pg0+7,_pg_dir		/* set present bit/user r/w */
	movl $pg1+7,_pg_dir+4		/*  --------- " " --------- */
	movl $pg2+7,_pg_dir+8		/*  --------- " " --------- */
	movl $pg3+7,_pg_dir+12		/*  --------- " " --------- */

	# 13. 设置所有的页表项全部
	movl $pg3+4092,%edi
	movl $0xfff007,%eax		/*  16Mb - 4096 + 7 (r/w user,p) */
	std
1:	stosl			/* fill pages backwards - more efficient :-) */
	subl $0x1000,%eax
	jge 1b

10.为什么不用call，而是用ret“调用”main函数？画出调用路线图，给出代码证据。

避免压入额外的返回地址，因为main函数是第一个被调用的函数，没有返回地址。
